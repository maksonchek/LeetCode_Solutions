##### **Задача**
https://leetcode.com/problems/summary-ranges/
Дан отсортированный массив с уникальными числами, например
```
[0,1,2,3,5,6,7,9]
```
Нужно найти в этом массиве последовательные числа и оставить в итоге только начало и конец последовательности. Если число не является частью последовательности, оставить это число в ответе
```
["0","1->3","5->7","9"]
```

##### **Логика решения**
Входной массив может быть пустым или содержать один элемент! Поэтому сначала нужно проверить это.

Нужно создать "оперативный" массив, в котором сначала будут два одинаковых элемента, первое значения входного массива. 

Далее начинаем итерироваться по исходному массиву, начиная с индекса 1.  Тут может быть два случая:
1) Элемент, который мы сейчас смотрим, на 1 больше последнего элемента оперативного массива. Это значит, последовательность есть. В этом случае просто обновляем последний элемент оперативного массива, записывая в него рассматриваемый элемент.
2) Элемент, который мы сейчас рассматриваем, не продолжает последовательность. В этом случае может быть ещё два случая:
    1) Значения элементов оперативного массива равны. Это значит, что это один элемент входного массива и в последовательность он не входил. Тогда просто записываем его в ответ так:
		```
		"число"
		```
    2)  Значения элементов оперативного массива не равны, а значит являются границами последовательности. Их записываем так:
	    ```
	    "первое число->второе число"
	    ```
	Также не забываем после записи в ответ обновить  элементы оперативного массива на рассматриваемый, чтобы можно было рассматривать новую последовательность объективно!
Важно помнить, что описанный выше алгоритм рассмотрит последний элемент входного массива, но не запишет его в ответ, зато запишет в оперативный массив.
Поэтому после всех итераций по исходному массиву надо сделать постобработку и выполнить пункты п2, исключая взаимодействие с исходным массивом.

##### **Решение**
```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        #[0,1,2,3,5,6,7,9]
        if len(nums) == 0:
            return []
        elif len(nums) == 1:
            return [f"{nums[0]}"]
        ans = []
        s = [nums[0], nums[0]]
        
        for r in range(1, len(nums)):
            if nums[r] - 1 == s[-1]:
                s[-1] = nums[r]
            else:
                if s[0] == s[-1]:
                    ans.append(f"{s[0]}")
                else:
                    ans.append(f"{s[0]}->{s[-1]}")
                s[0] = nums[r]
                s[-1] = nums[r]
                
        if s[0] == s[-1]:
            ans.append(f"{s[0]}")
        else:
            ans.append(f"{s[0]}->{s[-1]}")
            
        return ans
```
##### **Теги**
#Компетенции 
##### **Ссылки**
[[Алгоритмы и структуры данных]]