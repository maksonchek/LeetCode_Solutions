##### **Задача**
Дан массив и число k, нужно посчитать кол-во подмасивов, сумма которых равна k 
##### **Крайние случаи**
Числа могут быть отрицательными, поэтому скользящее окно тут не поможет
##### **Логика решения**
Решение за $O(n)$ позволяет добиться словарь, который хранит в себе все префиксные суммы, которые встречались по ходу движения по массиву и количество их значений. Логика такого подхода такая:
* Если текущая префиксная сумма минус $k$ уже есть в словаре, то к количеству способов получить $k$ добавляем значение по ключу префиксная сумма минус $k$, так как разность показывает, какое число нужно вычесть из текущей префиксной суммы, а это число - значение в словаре по ключу - означает, сколько есть комбинаций в сумме дающих такую префиксную сумму.
* Далее обновляем в словаре кол-во текущей префиксной суммы.

В итоге мы всего один раз проходимся по массиву, а словарь хранит в себе все возможные варианты префиксных сумм, поэтому лишних вычислений делать не понадобится.
##### **Решение**
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        pref_table = {}
        pref_table[0] = 1
        ans = 0
        pref = 0
        
        for n in nums:
            pref += n
            
            if pref - k in pref_table:
                ans += pref_table[pref - k]
            if pref in pref_table:
                pref_table[pref] += 1
            else:
                pref_table[pref] = 1
                
        return ans
```

##### **Теги**
#Компетенции 
##### **Ссылки**
[[Алгоритмы и структуры данных]]