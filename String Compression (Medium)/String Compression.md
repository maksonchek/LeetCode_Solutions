##### **Задача**
Дан массив строк типа
```
["a","a","b","b","b","b", "c"]
```
И нужно посчитать длину каждой последовательности одинаковых букв в этой строке и записать в **этот же массив**, если длина более 1, иначе записывается просто символ

```
["a", "2", "b", "4", "c"]
```

При этом если в последовательности было больше 9 значений, то каждая цифра числа записывается отдельно:

```
"123" -> "1", "2", "3"
```

На выходе нужно вернуть длину преобразованного массива, который несет информацию о последовательностях. То есть не длину самого массива, а только информативной его части!

Это означает, что после среза массива по этой длине может лежать что угодно. 
```
["a", "2", "b", "4", "c", "c", "b"...]
```
Этим мы и воспользуемся при решении.
##### **Крайние случаи**

Массив имеет одно значение. Для этого проверяем, если только один элемент во входящем массиве, то возвращаем его и всё.
##### **Логика решения**
Основная идея - это использовать два указателя для динамической замены значений в массиве. 

Левый указатель ставим на начало массива, правый будет итерироваться, начиная со второго значения массива.

Начинаем итерацию, и для каждой итерации возможно два случая:
1) Значение правого указателя равно значению предыдущего элемента. В этом случае просто прибавляем 1 к счётчику символа в последовательности.
2) Значение правого указателя не равно значению предыдущего элемента. В этом случае последовательность прерывается и нам нужно записать его длину, если символ был не один.  
	Для этого записываем в значение левого указателя значение символа, который мы хотим записать, **так как левый может указывать на мусорный неактуальный уже символ, который был посчитан!**. Далее если кол-во символов в последовательности больше 1, то циклом переставляем левый указатель вправо и записываем туда части числа. После этой итерации ещё раз сдвигаем левый указатель вправо, чтобы менять символы, а не числа, которые нам нужны.
	
После того, как правый указатель прошёлся по всему массиву, то необходимо обработать и записать последний символ, так как на нём цикл остановился и условие записи кол-ва проверится не может. Тут логика такая же, как и в одной итерации цикла, описанного выше.

В конце возвращаем длину среза массива до левого указателя, не прибавляя 1, так как он указывает уже на мусорное значение, а не число и нам оно не нужно (срез не включает правый индекс)
##### **Решение**
```python
class Solution:

    def compress(self, chars: List[str]) -> int:
        #["a","a","b","b","b","b", "c"]
        #["a", "b", "c"]
        #["a", "2", "b", "4", "c"]
        #["a","a","a","b","b","a","a"]

        if len(chars) == 1:
            return 1

        l = 0
        cnt = 1 #Счётчик начинаетмя с 1, т.к правый указатель не смотрел на 1-й элемент массива

        for r in range(1, len(chars)):
            if chars[r-1] != chars[r]:
                chars[l] = chars[r-1]
                if cnt > 1:
                    for c in str(cnt):
                        l += 1
                        chars[l] = c
                l += 1
                cnt = 1
            else:
                cnt += 1
  
        chars[l] = chars[-1]
        if cnt > 1:
            for c in str(cnt):
                l += 1
                chars[l] = c
        l += 1

        return len(chars[:l])
```
##### **Теги**
#Компетенции 
##### **Ссылки**
[[Алгоритмы и структуры данных]]