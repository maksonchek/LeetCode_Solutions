Задаче с LeetCode - https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/

##### **Задача**
Задача заключается в том, что дан массив ноликов и единичек и нужно найти максимальную длину подмассива, если удалить из него один элемент. При этом п подмассиве не должно быть больше одного нуля. Если нулей совсем нет, один элемент всё равно надо удалить.
##### **Логика решения**
Идея - применить скользящее окно, где правый указатель двигается по циклу *for* и подсчитывает кол-во нулей и единиц в подотрезке. И если кол-во нулей стало больше единицы, то сохраняем максимальную длину за всё время. 

Далее запускается цикл *while*, передвигая левый указатель. **!Важно, чтобы левый указатель всегда был меньше правого, иначе выход за пределы массива или бесконечный цикл!** Левый указатель позволяет динамически контролировать сумму подотрезка и кол-во нулей в нём. Пока *l* *<* *r* левый указатель двигается вперёд, уменьшая кол-во нулей или единичек, которые остаются позади

Такой алгоритм не зависает при краевых случаях, когда или все нули или все единицы, т.к *r* гарантированно двигается вперёд
##### **Решение**

```python
class Solution:

    def longestSubarray(self, nums: List[int]) -> int:

        #[0, 1, 1, 1, 0, 0, 1, 0, 1,1, 0, 1, 1]
        #[1,1,1,1]
        #[0,0,0,0]

        l = 0
        cnt = 0
        s = 0
        ans = 0

        for r in range(len(nums)):
            if nums[r] == 0:
                cnt += 1
            elif nums[r] == 1:
                s += 1

            ans = max(ans, s)

            while cnt > 1 and l < r:
                if nums[l] == 0:
                    cnt -= 1
                elif nums[l] == 1:
                    s -= 1
                l += 1

        return ans if cnt > 0 else ans - 1
```

##### **Теги**
#Компетенции 
##### **Ссылки**
[[Алгоритмы и структуры данных]]